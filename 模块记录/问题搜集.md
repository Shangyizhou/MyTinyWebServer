## 线程池保证线程同步

使用信号量和互斥锁保证线程安全，如果任务队列没有任务，工作线程提前访问了任务队列，会先调用`P`操作，`sem_wait`，因为初始化为0，先减去1，得到的是负值，让线程阻塞在这里。必须得让生产者调用`V`操作，增加信号量才可以。如果工作队列退出阻塞状态了，还需要竞争抢锁才可以访问共享区，然后弹出头元素（头任务），执行`Process`函数。

- 使用信号量来保证线程同步，
- 信号量类`Sem`
  - 初始化信号量值为`0`,用于设置线程同步
  - 对于工作线程，只有请求队列有任务时才会执行任务，而sem <= 0 的时候是会阻塞线程的，所以设置为`0`一开始是阻塞线程的。
  - 当有任务的时候，执行V操作，增加信号量值，线程取走任务后，执行P操作，减少信号量值
    - sem_wait()：当`sem <= 0`阻塞，当`sem > 0`，则进入公共区并减一
    - sem_post()：加1

## 我的定时器设计问题

我一开始觉得定时器设计有些奇怪，为什么定时器内部需要包含客户端连接的结构，而客户端连接的结构也需要包含进定时器内部。

后来写处理代码的时候发现，定时器内部的`tick`函数按顺序逐个检查管理定时器是否超时，如果超时，那么需要调用该定时器的回调函数，也就是关闭连接。这个过程需要往里面传递文件描述符，所以自然，我们每个定时器都需要知道它管理客户的地址信息。

而对于客户端，我们写完响应报文后如果发现是短连接，那么我们需要关闭连接，移除定时器。这个操作是对于`users_[connfd]`进行的，里面包含有定时器的结构。我们需要调取该定时器的回调函数，关闭连接。

所以，这是一个互相包含的关系。

## 阻塞非阻塞代码

思考，有这么多的文件描述符，比如`listenfd`和`connfd`还有传递信号得`pipefd`，使用阻塞非阻塞区别是什么？

对于`listenfd`，使用非阻塞描述符

## 线程池相关

### 线程池工作线程一直等待吗

没错，除非信号量大于0，否则一直等待。

是的，等待新任务的唤醒；

### 线程同步机制

信号量、条件变量、互斥量等；

### **你的线程池工作线程处理完一个任务后的状态是什么？**

如果请求队列为空，则该线程进入线程池中等待；若不为空，则该线程跟其他线程一起进行任务的竞争；

### **如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢**

该项目是基于IO复用的并发模式。**需要注意的是，不是一个客户连接就对应一个线程**！如果真是如此，淘宝双12服务器早就崩了！当客户连接有事件需要处理的时，epoll会进行事件提醒，而后讲对应的任务加入请求队列，等待工作线程竞争执行。**如果速度还是慢，那就只能够增大线程池容量**，或者考虑集群分布式的做法。

### **如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?**

会，因为线程的数量是固定的，如果一个客户请求长时间占用着线程资源，势必会影响到服务器对外的整体响应速度。

解决的策略可以是给每一个线程处理任务设定一个时间阈值，当某一个客户请求时间过长，则将其置于任务请求最后，或断开连接。

或者，按照任务优先级得策略来做

## 并发模型

### 服务器使用事件处理模型（事件处理模式）

**使用同步I/O模型实现Reactor模式**

- 主线程往epoll内核事件种注册socket上的读就绪事件
- 主线程调用epoll_wait等待socket上有数据可读
- 当socket上有数据可读时，epoll_wait通知主线程，主线程则将socket可读事件放入请求队列（我们需要初始化该连接再封装进入请求队列）
- 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
- 主线程调用epoll_wait等待socket可写
- 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列
- 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果

### 两种模型区别

与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。

- 主线程调用aio_read函数向内核注册socket上的读完成事件并 告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序 （这里以信号为例，详情请参考sigevent的man手册）。
- 主线程继续处理其他逻辑。
- 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 
- 应用程序预先定义好的信号处理函数选择一个工作线程来处理 客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓】冲区的位置，以及写操 作完成时如何通知应用程序（仍然以信号为例）。
- 主线程继续处理其他逻辑。 
- 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 
- 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。

### 半同步半反应堆（并发模式）

异步线程只有一个，由主线程来充当。它负责监听全部socket上的事件。

(1)如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接收连接得到新的连接socket，然后往epoll内核事件表中注册该连接socket的读写事件。

(2)如果连接socket上有读写事件发生，则有新的客户请求到来,或者有数据要发送，主线程就将该连接socket插入到请求队列中。

(3)所有工作线程都睡眠在请求队列上,当有任务到来时,会有一定的算法或机制来唤醒工作线程来处理新连接的请求。

**缺点:** 

缺点1:主线程和工作线程操作队列，需要加锁保护,会耗费一定的cpu资源。 

缺点2:如果客户数量多，而工作线程较少,处理客户端请求的能力有限,会导致清楚队列中堆积很多任务对象,客户端的响应速度将越来越慢.如果通过增加工作线程来解决这一问题，则工作线程的切换也将耗费大量cpu时间

**更高效点的半同步/半异步模式**

和上面模式不同的是

(1)主线程只负责管理侦听socket。

**(2)连接socket由工作线程来管理。我这个连接socket得工作是主线程完成** 

(3)当有新的连接到来时,主线程将返回的连接socket派发到工作线程。

(4)该新连接socket上的任何IO操作都由后续指定的工作线程来处理,直到客户关闭连接。

工作线程自己注册连接socket的读写事件到自己的epoll内核事件表中。

![image-20220327174413119](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20220327174413119.png)

### epoll等IO复用

- 对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，**每次调用都需要将整个集合拷贝到内核态**；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要**执行一个系统调用**。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。
- select使用线性表描述文件描述符集合，**文件描述符有上限**；poll使用**链表来描述**；epoll底层通过红黑树来描述，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。
- select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，**它们会采用遍历的方式**，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，**会自动触发epoll回调函数通知epoll文件描述符**，然后内核将这些就绪的文件描述符放到之前提到的**ready list中等待epoll_wait调用后被处理**。
- select和poll都只能工作在**相对低效的LT模式下**，而epoll同时支持LT和ET模式。
- 综上，**当监测的fd数量较小**，且各个fd都很活跃的情况下，建议使用select和poll；**当监听的fd数量较多**，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。

## HTTP报文解析

### 为什么使用状态机

### 画状态转移图

### GET POST区别

- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 

- GET参数通过URL传递，POST放在Request body中。

- GET产生一个TCP数据包；POST产生两个TCP数据包。

  - 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

    而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

    因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？

    1. GET与POST都有自己的语义，不能随便混用。

    2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

    3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

     

> [GET和POST两种基本请求方法的区别 - 在途中# - 博客园 (cnblogs.com)](https://www.cnblogs.com/logsharing/p/8448446.html)

## 定时器相关

### 为什么使用定时器

处理定时任务，或者非活跃连接，节省系统资源；

### 定时器工作原理

服务器就为各事件分配一个定时器。该项目使用SIGALRM信号来实现定时器，首先每一个定时事件都处于一个升序链表上，**通过alarm()函数周期性触发SIGALRM信号**，而后信号回调函数利用管道通知主循环，主循环接收到信号之后对升序链表上的定时器进行处理：若一定时间内无数据交换则关闭连接。

### 双向链表删除和添加时间复杂度

——添加一般情况下都是O(N)，删除只需要O(1)。从双向链表的方式优化不太现实，可以考虑使用最小堆、或者跳表的数据结构，[跳表详见](https://zhuanlan.zhihu.com/p/360087451)。

### 最小堆优化得复杂度和工作原理

——最小堆以每个定时器的过期时间进行排序，最小的定时器位于堆顶，当SIGALRM信号触发tick（）函数时执行过期定时器清除，如果堆顶的定时器时间过期，则删除，并重新建堆，再判定是否过期，如此循环直到未过期为止。

插入，O(logn)；

删除，O(logN)；

## 参考

- [Tinywebserver——服务器常问面试题！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/368154495)
- [(203条消息) 【面试专栏】自己整理的WebServer项目问题_温酒煮青梅的博客-CSDN博客](https://blog.csdn.net/weixin_44484715/article/details/120825122?ops_request_misc=%7B%22request%5Fid%22%3A%22164801822216780366515645%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=164801822216780366515645&biz_id=0&spm=1018.2226.3001.4187)
- [(203条消息) 近四十场面试汇聚成的超全Web服务器面经总结_Netfishless的博客-CSDN博客_web服务器项目面试](https://blog.csdn.net/ClaireSy/article/details/122436929?ops_request_misc=%7B%22request%5Fid%22%3A%22164801870116782089383195%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=164801870116782089383195&biz_id=0&spm=1018.2226.3001.4187)
- [web服务器项目部分问题汇总 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/269247362)
- [(90 封私信 / 83 条消息) 半同步半反应堆 - 搜索结果 - 知乎 (zhihu.com)](https://www.zhihu.com/search?type=content&q=半同步半反应堆)
- 